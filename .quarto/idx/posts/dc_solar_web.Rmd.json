{"title":"cross_section_models","markdown":{"yaml":{"title":"cross_section_models","author":"hk939","date":"2024-02-26","output":{"html_document":{"code-fold":true}}},"headingText":"install packages","containsRefs":false,"markdown":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(warning = FALSE, message = FALSE)\n\nlibrary(arrow)\nlibrary(tidyverse)\nlibrary(tidycensus)\nlibrary(sf)\nlibrary(sandwich)\nlibrary(viridis)  # for improved color scales\nlibrary(car)\nlibrary(lmtest)\nlibrary(stargazer)\nlibrary(broom)\nlibrary(lme4)\nlibrary(Matrix)\nlibrary(lmtest)\nlibrary(recipes)   # For preprocessing steps\nlibrary(modeldata) # For data splitting\nlibrary(caret)\nlibrary(googledrive)\nlibrary(kableExtra)\n\n\n```\n\n# Solar Adoption in DC\n\nSolar panels are currently XXX of the US market, with adoption low.\n\nRenewable Portfolio Standard (RPS) policies are designed to increase uptake of renewable energy.\n\nDC's RPS is one of the country's most ambitious, \n\nPolicy changes\n\n-\t**Distributed Generation Amendment Act of 2011 (Oct 2011)**\n    -\tshall not certify any tier one renewable source solar energy system larger than 5 MW in capacity or not in the District\n\n-\t**Renewable Energy Portfolio Standard Amendment Act (Apr 2015)**\n    -\tBiomass related\n\n-\t**Renewable Portfolio Standard Expansion Amendment Act (Oct. 2016)**\n    - Raised RPS requirements\n    - Raised ACP trajectory\n\n-\t**Clean Energy DC Omnibus Amendment Act ( March 2022)**\n    - Increased the solar RPS requirements to 5.5% by 2032 \n    - Increased ACP trajectory\n\n\n```{r, echo=FALSE}\n\n# inset chatCompletion\n# Create the data frame\nyear <- 2011:2041\ntier_one_renewable_percent <- c(4, 5, 6.5, 8, 9.5, 11.5, 13.5, 15.5, 17.5, 20, 26.25, 32.5, 38.75, 45.0, 52.0, 59.0, 66.0, 73.0, 80.0, 87.0, 94.0, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100)\nsolar_energy <- c(0.4, 0.5, 0.5, 0.6, 0.7, 0.825, 0.98, 1.15, 1.85, 2.175, 2.5, 2.6, 3.0, 3.65, 4.3, 5.0, 5.65, 6.3, 7.0, 7.65, 8.3, 9.0, 9.65, 10.3, 11.0, 11.65, 12.3, 13.0, 13.65, 14.3, 15.0)\n\ndata <- data.frame(year, tier_one_renewable_percent, solar_energy)\n\ndata$gap <- data$tier_one_renewable_percent-data$solar_energy\n\n# Assuming 'data' is your dataframe\n# Add a new column for the act labels\ndata$Act <- NA  # Initialize with NA\ndata$Act[data$year == 2011] <- \"Distributed Generation Amendment Act of 2011\"\ndata$Act[data$year == 2016] <- \"Renewable Portfolio Standard Expansion Amendment Act\"\ndata$Act[data$year == 2022] <- \"Clean Energy DC Omnibus Amendment Act\"\n\n# Now, plotting with enhancements and adding specific labels\np <- ggplot(data, aes(x = year)) +\n  geom_line(aes(y = tier_one_renewable_percent, color = \"Tier-One Renewable Percent\"), size = 1) +\n  geom_area(aes(y = tier_one_renewable_percent), fill = \"skyblue\", alpha = 0.5) +\n  geom_line(aes(y = solar_energy, color = \"Solar Energy\"), size = 1) +\n  geom_area(aes(y = solar_energy), fill = \"yellow\", alpha = 0.5) +\n  geom_point(aes(y = tier_one_renewable_percent), color = \"#0099f9\", size = 2) +\n  geom_label(data = data %>% filter(!is.na(Act)), aes(y = tier_one_renewable_percent, label = Act), nudge_x = 0.25, nudge_y = 0.25, check_overlap = TRUE, size = 3, label.size = 0) +\n  scale_color_manual(values = c(\"Tier-One Renewable Percent\" = \"#1f77b4\", \"Solar Energy\" = \"yellow\")) +\n  labs(x = \"Year\", y = \"Percent / Energy\", title = \"Tier-One Renewable Percent and Solar Energy Over Time\", color = \"Metrics\") +\n  theme_minimal() +\n  theme(legend.position = \"top\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        plot.title = element_text(size = 16, face = \"bold\"),\n        axis.title = element_text(size = 14),\n        plot.margin = margin(10, 10, 10, 10))\n\n# Print the plot\nprint(p)\n\n\n```\n\n### What was the actual ratio in 2023?\n\n\nConsumption is given by PJM STATS CITE. DC generated just 23% of its electricity from solar in 2023.\n\nBut there has been tremendous growth.\n\n```{r, echo=FALSE}\n\n# Fetch data for DC\n# Convert sf object to GeoJSON\n# st_write(joined_df, \"solar_acs2019_bg.geojson\", driver = \"GeoJSON\")\n\nlibrary(gganimate)\n\ndf_time <- read_csv('data/tot_solar_time.csv')\n\n#create the plot\np <- ggplot(df_time, aes(x = date, y = cum_mw)) +\n  geom_line(aes(group = 1), color = \"#1f77b4\", size = 1.5) +  # Increase line thickness with `size`\n  geom_point( color = \"#0099f9\") + # Draw points\n  labs(x = \"Year\", y = \"Capacity added (MW)\", title = \"Solar Boom in DC\") +\n   theme(\n    text = element_text(color = \"black\"), # Make all text black\n    plot.title = element_text(size = 22, face = \"bold\", color = \"black\"), # Enlarge and bolden the title\n    axis.title = element_text(size = 16, face = \"bold\", color = \"black\"), # Bolden axis titles\n    axis.text = element_text(size = 12) # Adjust size of axis text if needed\n  ) + ggthemes::theme_solarized() \n  # theme(legend.position = \"none\") # Hide the legend\n# Creating the plot with ggplot2\n\n# Animate the plot\nanim <- p + transition_reveal(date) + \n  enter_grow() +  # Animation for entering points\n  exit_fade() +   # Animation for exiting points\n  ease_aes('cubic-in-out') + # Animation speed\n  labs(title = 'Year: {frame_along}', subtitle = \"Tier-One Renewable Percent\") # Update title with year\n\n# Render the animation\nanimate(anim, duration = 10, fps = 30, width = 800, height = 600, renderer =gifski_renderer())\n\n# Save the animation\n# anim_save(\"dc_solar_anim.gif\", animation = anim)\n\n\n# ts_data_ts <- ts(df_time %>% select(date, cum_mw))\n# \n# library(strucchange)\n# bp <- breakpoints(ts_data_ts ~ 1)\n# \n# plot(bp)\n# # Assuming ts_data is your time series data\n# cpt.mean <- cpt.mean(ts_data, method=\"PELT\")\n# \n#   # Plot the changes\n# plot(cpt.mean)\n# # Display the plot\n# # ggsave(\"renewable_energy_plot.png\", width = 14, height = 7, dpi = 100)\n\n\n```\n\n\n## Sample `gganimate` code\n\n```{r, echo=TRUE, eval=FALSE}\n#| code-fold: true\n#| code-summary: \"Show the code\"\n\n# Animate the plot\nanim <- p + transition_reveal(date) + \n  enter_grow() +  # Animation for entering points\n  exit_fade() +   # Animation for exiting points\n  ease_aes('cubic-in-out') + # Animation speed\n  labs(title = 'Year: {frame_along}', subtitle = \"Tier-One Renewable Percent\") # Update title with year\n\n# Render the animation\nanimate(anim, duration = 10, fps = 30, width = 800, height = 600, renderer =gifski_renderer())\n\n\n\n```\n\n\n## DC Open Data - Buildings and solar\n\nWith the help of DC Open Data’s frequently updated and granular urban data on buildings, it is straightforward to combine these into the largest single-city datasets for almost all of DC’s 110,000 residential buildings. \n- CAMA\n\n- DC Solar monthly\n\n- **Note**:\nLinking these two datasets is more complex than a single merge. The common thing is address, but CAMA doesn't have address directly. It has the Square Suffix Lot (SSL) number, which identifies the plot of land on which a building sits. Some lots have multiple buildings, and some buildings/complexes span multiple lots.\n\nWe then have a dataset with the below outline\n\n```{r, echo=FALSE}\n\n\n## AUTHENTICATE Google DRIVE account\n# drive_auth()\n# \n# \n# # download this to local drive\n# drive_download(as_id(\"1Ho9fKEotF9B6aG85SpvpNPXEK1sV4_78\"),\n#                path = \"output_data/residential_cross_sec.parquet\", overwrite = TRUE)\n\ndf <- read_parquet('data/cross_sec_api_12k.parquet')\ndf$cap_kw <- df$`Capacity (MW)`*1000\n\ndf$lat <- df$LATITUDE\ndf$lon <- df$LONGITUDE\ndf <- df %>%\n  filter(!is.na(lat) & !is.na(lon) \n         & lat != \"NA\" & lon != \"NA\") %>%\n  st_as_sf(coords = c(\"lon\", \"lat\"), crs = 4326) %>%\n   mutate(cap_kw = replace_na(cap_kw, 0))\n\n\n# add census block group data\n###############\n\nquantile_99 <- quantile(df$cap_kw, 0.99, na.rm = TRUE)\n\n\n# Preparing subsets\ndf_with_0 <- df %>% \n  filter(cap_kw == 0) %>%\n  select(SSL, STYLE_D, ROOF_D, NBHDNAME, cap_kw, max_sun_hours, min_dc_kwh) %>%\n  sample_n(2)\n\ndf_without_0 <- df %>%\n  filter(`Capacity (MW)` > 0 & `Capacity (MW)` <= quantile_99) %>%\n  select(SSL, STYLE_D, ROOF_D, NBHDNAME, cap_kw, max_sun_hours, min_dc_kwh)%>%\n  sample_n(3)\n\n# Combining the subsets\ndf_sample <- bind_rows(df_with_0, df_without_0)\n\n# drop geom\ndf_sample <- st_set_geometry(df_sample, NULL)\n\n#save\ndf_sample <- df_sample %>% select(SSL, STYLE_D, ROOF_D, NBHDNAME, cap_kw, max_sun_hours, min_dc_kwh)\n\n# write_csv(df_sample, 'kable_tab.csv')\n# \n# # Apply cell_spec to cap_mw for dynamic coloring\ndf_sample$cap_kw <- cell_spec(df_sample$cap_kw, \"html\",\n                              color = \"white\",\n                              bold = TRUE,\n                              background = spec_color(df_sample$cap_kw, end = 0.9, option = \"A\"))\n\n# Generating the table\nknitr::kable(df_sample, \"html\", escape = FALSE) %>%\n  kable_styling(full_width = F, fixed_thead=TRUE,\n                bootstrap_options = c(\"striped\", \"hover\"))\n\n\n```\n\n\nWhy is this interesting? If you look at this CITE PAPER - ML can reduce 'SOFT COSTS'\n\n## The DC Solar Market\n\nHow much does it cost to install a solar panel on average? \nInstallation cost = $13,000\n\nIn a centrally planned economy, the DC Mayor could issue an edict, and armies of government workers would install a solar panel on each roof, and the goal would be met within a week. However, that is not how a free-market democracy works, and we would \n\nA household in DC can factor in four types of incentives available for a solar installation :\n\n-\t**Federal rebate**\n-\t**SREC**\n\n::: {.callout-tip}\n## Tip with Title\nThis is an example of a callout with a title.\n:::\n\n-\t**Net metering**\n\nThere is another type of indirect incentive, which might function as a 'stick' to the above 'carrots'. This is the **Building Energy Benchmarking Policy (BEPS)**, which aims to identify and impose financial penalties on large buildings (>10,000 sq feet) with greater than average energy consumption\n\nTwo studies have been conducted on the state of solar adoption in Washington DC, by Synapse Energy Economics in 2019 and 2022.\n\nThe second study lays out the factors which hinder higher adoption in DC.\n\n- Renters (less than 30% single-family owner-occupied housing) \n- Rising ACPs - People will anticipate higher compensation in future, and may delay purchases.\n- Electricity prices: Higher electricity and enery prices, or basically that increases energy expenditure will lead people to \n\nThe shortfall between SREC supply and RPS requirement gives the revenues to DC DOEE\n\nCITE PAPER - SREC protectionism did increase adoption\n\n## Get census data using `tidyCensus`\n\n```{r, echo=TRUE, eval=FALSE}\n#| code-fold: true\n#| code-summary: \"Show the code\"\n\nst_acs <- get_acs(variables = c(total_pop = \"B02001_001E\", \n                                  owner_occupied = \"B25003_002E\",\n                                  total_occupied = \"B25003_001E\"),\n                    geography = \"block group\",\n                    geometry = TRUE,\n                    state = \"DC\", \n                    year = 2019) \n```\n\n### Aggregate solar data to the block group level\n\nWhat does data from the American Community Survey tell us, about what these \n\n```{r, echo=FALSE, message=FALSE, warning=FALSE, results=FALSE}\n\nbg_df <- st_read(\"data/solar_acs2019_bg.geojson\")\n\n# Perform a spatial join: add data from bg_df to df_sample based on their spatial relationship\n# zip_data <- zip_data %>%  st_make_valid()\n# joined_sf <- st_join(zip_data, bg_df, join = st_contains)\n\n# Improved plot for polygon sf object\n# basic_plot <- ggplot(data = bg_df) +\n#   geom_sf(aes(fill = total_capacity), color = \"black\", size = 0.2) +  # Fill polygons and add borders\n#   scale_fill_viridis(option = \"C\", direction = -1) +  # Viridis color scale\n#   labs(\n#     title = \"Per Capita Solar Capacity\",\n#     fill = \"Per Capita kW\",\n#     caption = \"Data Source: ACS 2019, DCPSC 2023\"\n#   ) +\n#   theme_minimal() +\n#   theme(\n#     legend.position = \"right\",\n#     plot.title = element_text(hjust = 0.5),  # Center the plot title\n#     plot.caption = element_text(hjust = 0, size = 8)  # Align caption\n#   )\n# \n# basic_plot\n# \n# model_1 <- lm(pc_capkw ~ own_rate, data = bg_df)\n# # Calculate robust standard errors\n# # robust_se1 <- vcovHC(model_1, type = \"HC1\")\n# # robust_se1 <- as.vector(coeftest(model_1, vcovHC(model_1, type = \"HC1\"))[, \"Std. Error\"])\n# -\n# Assuming 'joined_sf' is your dataframe with 'own_rate' and 'tot_capkw' variables.\n\n# Create 10 quantiles of ownership rate\nbg_df <- bg_df %>%\n  mutate(quantile = ntile(own_rate, 20))\n\n# Compute the mean of 'tot_capkw' within each quantile\nquantile_avgs <- bg_df %>%\n  group_by(quantile) %>%\n  summarise(tot_cap = sum(total_capacity),\n            tot_pop = sum(total_pop)) %>%\n  mutate(cap_kw_pc = tot_cap/tot_pop)\n\n###########################################################\n# Plot the averages as points\nggplot(quantile_avgs, aes(x = as.factor(quantile), y = cap_kw_pc)) +\n  geom_point(aes(color = as.factor(quantile)), size = 3) +\n  geom_smooth(aes(x = as.numeric(as.factor(quantile))), method = \"lm\", formula = y ~ x, se = TRUE, color = \"blue\") +\n  labs(x = \"Ownership Rate Quantile\", y = \"Average Total Capacity (KW)\", title = \"Average Total Capacity by Ownership Rate Quantiles\") +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 90, \n                                   vjust = 0.5, \n                                   hjust=1),\n        legend.position = \"none\")\n\n# Note: Replace 'joined_sf' with your actual dataframe name.\n###########################################################\n\n```\n\n\n## Ownership correlates with solar adoption.\n\n## TODO map layer different\n\n# Building level maps\n\nThe following shows a simple\n\n```{r, echo=FALSE}\nlibrary(leaflet)\nlibrary(RColorBrewer)\n\nward_data <- readRDS(\"data/ward_solar.rds\")\nzip_data <- readRDS(\"data/zipcode_solar.rds\")\nsolar_build <- readRDS(\"data/solar_build.rds\")\n\ndata <- zip_data\n# Replace \"ward\" with \"zipcode\" as needed\nspatialLevel <- \"ward\" # or \"zipcode\"\n\n# Check the spatial level and generate the map accordingly\npal <- colorNumeric(palette = \"YlOrRd\", domain = data$total_capacity_mw)\n  \n# map <- leaflet(zip_data) %>%\n#     addProviderTiles(providers$CartoDB.Positron) %>%\n#     addPolygons(\n#       layerId = ~NAME,\n#       fillColor = ~pal(total_capacity_mw),\n#       color = \"#444444\",\n#       weight = 1,\n#       smoothFactor = 0.5,\n#       popup = ~paste(\"Zip/Ward:\", NAME,\n#                      \"<br>Total Capacity MW:\", total_capacity_mw,\n#                      \"<br>Percentage Solar:\", perc_solar),\n#       highlightOptions = highlightOptions(weight = 2, \n#                                           color = \"white\",\n#                                           bringToFront = TRUE))\n\n# print(map)\n\n########################################################3\n## building\n\nspatialLevel <- \"build\" # or \"zipcode\"\n\n# Check the spatial level and generate the map accordingly\npal <- colorNumeric(palette = \"YlOrRd\", domain = solar_build$`Capacity (MW)`)\n  \nmap <- leaflet(solar_build) %>%\n    addProviderTiles(providers$CartoDB.Positron) %>%\n    addPolygons(\n      layerId = ~Number,\n      fillColor = ~pal(`Capacity (MW)`),\n      color = \"#444444\",\n      weight = 1,\n      smoothFactor = 0.5,\n      popup = ~paste(\"Address\", `Facility Address`,\n                     \"<br>Total Capacity MW:\", `Capacity (MW)`\n                     # \"<br>Percentage Solar:\",\n                     ),\n      highlightOptions = highlightOptions(weight = 2, color = \"white\", bringToFront = TRUE)) %>%\n    setView(lng = -77.0164, lat = 38.9047, zoom = 12)  # Set initial view; adjust coordinates and zoom as needed\n\n# Add a mini-map\nmap %>% addMiniMap(tiles = providers$CartoDB.Positron,\n                   toggleDisplay = TRUE,\n                   position = \"bottomright\")\n\nprint(map)\n\n\n```\n\n\n\n\n## Check out this in-progress dashboard here!\n\n","srcMarkdownNoYaml":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(warning = FALSE, message = FALSE)\n\n# install packages\nlibrary(arrow)\nlibrary(tidyverse)\nlibrary(tidycensus)\nlibrary(sf)\nlibrary(sandwich)\nlibrary(viridis)  # for improved color scales\nlibrary(car)\nlibrary(lmtest)\nlibrary(stargazer)\nlibrary(broom)\nlibrary(lme4)\nlibrary(Matrix)\nlibrary(lmtest)\nlibrary(recipes)   # For preprocessing steps\nlibrary(modeldata) # For data splitting\nlibrary(caret)\nlibrary(googledrive)\nlibrary(kableExtra)\n\n\n```\n\n# Solar Adoption in DC\n\nSolar panels are currently XXX of the US market, with adoption low.\n\nRenewable Portfolio Standard (RPS) policies are designed to increase uptake of renewable energy.\n\nDC's RPS is one of the country's most ambitious, \n\nPolicy changes\n\n-\t**Distributed Generation Amendment Act of 2011 (Oct 2011)**\n    -\tshall not certify any tier one renewable source solar energy system larger than 5 MW in capacity or not in the District\n\n-\t**Renewable Energy Portfolio Standard Amendment Act (Apr 2015)**\n    -\tBiomass related\n\n-\t**Renewable Portfolio Standard Expansion Amendment Act (Oct. 2016)**\n    - Raised RPS requirements\n    - Raised ACP trajectory\n\n-\t**Clean Energy DC Omnibus Amendment Act ( March 2022)**\n    - Increased the solar RPS requirements to 5.5% by 2032 \n    - Increased ACP trajectory\n\n\n```{r, echo=FALSE}\n\n# inset chatCompletion\n# Create the data frame\nyear <- 2011:2041\ntier_one_renewable_percent <- c(4, 5, 6.5, 8, 9.5, 11.5, 13.5, 15.5, 17.5, 20, 26.25, 32.5, 38.75, 45.0, 52.0, 59.0, 66.0, 73.0, 80.0, 87.0, 94.0, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100)\nsolar_energy <- c(0.4, 0.5, 0.5, 0.6, 0.7, 0.825, 0.98, 1.15, 1.85, 2.175, 2.5, 2.6, 3.0, 3.65, 4.3, 5.0, 5.65, 6.3, 7.0, 7.65, 8.3, 9.0, 9.65, 10.3, 11.0, 11.65, 12.3, 13.0, 13.65, 14.3, 15.0)\n\ndata <- data.frame(year, tier_one_renewable_percent, solar_energy)\n\ndata$gap <- data$tier_one_renewable_percent-data$solar_energy\n\n# Assuming 'data' is your dataframe\n# Add a new column for the act labels\ndata$Act <- NA  # Initialize with NA\ndata$Act[data$year == 2011] <- \"Distributed Generation Amendment Act of 2011\"\ndata$Act[data$year == 2016] <- \"Renewable Portfolio Standard Expansion Amendment Act\"\ndata$Act[data$year == 2022] <- \"Clean Energy DC Omnibus Amendment Act\"\n\n# Now, plotting with enhancements and adding specific labels\np <- ggplot(data, aes(x = year)) +\n  geom_line(aes(y = tier_one_renewable_percent, color = \"Tier-One Renewable Percent\"), size = 1) +\n  geom_area(aes(y = tier_one_renewable_percent), fill = \"skyblue\", alpha = 0.5) +\n  geom_line(aes(y = solar_energy, color = \"Solar Energy\"), size = 1) +\n  geom_area(aes(y = solar_energy), fill = \"yellow\", alpha = 0.5) +\n  geom_point(aes(y = tier_one_renewable_percent), color = \"#0099f9\", size = 2) +\n  geom_label(data = data %>% filter(!is.na(Act)), aes(y = tier_one_renewable_percent, label = Act), nudge_x = 0.25, nudge_y = 0.25, check_overlap = TRUE, size = 3, label.size = 0) +\n  scale_color_manual(values = c(\"Tier-One Renewable Percent\" = \"#1f77b4\", \"Solar Energy\" = \"yellow\")) +\n  labs(x = \"Year\", y = \"Percent / Energy\", title = \"Tier-One Renewable Percent and Solar Energy Over Time\", color = \"Metrics\") +\n  theme_minimal() +\n  theme(legend.position = \"top\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        plot.title = element_text(size = 16, face = \"bold\"),\n        axis.title = element_text(size = 14),\n        plot.margin = margin(10, 10, 10, 10))\n\n# Print the plot\nprint(p)\n\n\n```\n\n### What was the actual ratio in 2023?\n\n\nConsumption is given by PJM STATS CITE. DC generated just 23% of its electricity from solar in 2023.\n\nBut there has been tremendous growth.\n\n```{r, echo=FALSE}\n\n# Fetch data for DC\n# Convert sf object to GeoJSON\n# st_write(joined_df, \"solar_acs2019_bg.geojson\", driver = \"GeoJSON\")\n\nlibrary(gganimate)\n\ndf_time <- read_csv('data/tot_solar_time.csv')\n\n#create the plot\np <- ggplot(df_time, aes(x = date, y = cum_mw)) +\n  geom_line(aes(group = 1), color = \"#1f77b4\", size = 1.5) +  # Increase line thickness with `size`\n  geom_point( color = \"#0099f9\") + # Draw points\n  labs(x = \"Year\", y = \"Capacity added (MW)\", title = \"Solar Boom in DC\") +\n   theme(\n    text = element_text(color = \"black\"), # Make all text black\n    plot.title = element_text(size = 22, face = \"bold\", color = \"black\"), # Enlarge and bolden the title\n    axis.title = element_text(size = 16, face = \"bold\", color = \"black\"), # Bolden axis titles\n    axis.text = element_text(size = 12) # Adjust size of axis text if needed\n  ) + ggthemes::theme_solarized() \n  # theme(legend.position = \"none\") # Hide the legend\n# Creating the plot with ggplot2\n\n# Animate the plot\nanim <- p + transition_reveal(date) + \n  enter_grow() +  # Animation for entering points\n  exit_fade() +   # Animation for exiting points\n  ease_aes('cubic-in-out') + # Animation speed\n  labs(title = 'Year: {frame_along}', subtitle = \"Tier-One Renewable Percent\") # Update title with year\n\n# Render the animation\nanimate(anim, duration = 10, fps = 30, width = 800, height = 600, renderer =gifski_renderer())\n\n# Save the animation\n# anim_save(\"dc_solar_anim.gif\", animation = anim)\n\n\n# ts_data_ts <- ts(df_time %>% select(date, cum_mw))\n# \n# library(strucchange)\n# bp <- breakpoints(ts_data_ts ~ 1)\n# \n# plot(bp)\n# # Assuming ts_data is your time series data\n# cpt.mean <- cpt.mean(ts_data, method=\"PELT\")\n# \n#   # Plot the changes\n# plot(cpt.mean)\n# # Display the plot\n# # ggsave(\"renewable_energy_plot.png\", width = 14, height = 7, dpi = 100)\n\n\n```\n\n\n## Sample `gganimate` code\n\n```{r, echo=TRUE, eval=FALSE}\n#| code-fold: true\n#| code-summary: \"Show the code\"\n\n# Animate the plot\nanim <- p + transition_reveal(date) + \n  enter_grow() +  # Animation for entering points\n  exit_fade() +   # Animation for exiting points\n  ease_aes('cubic-in-out') + # Animation speed\n  labs(title = 'Year: {frame_along}', subtitle = \"Tier-One Renewable Percent\") # Update title with year\n\n# Render the animation\nanimate(anim, duration = 10, fps = 30, width = 800, height = 600, renderer =gifski_renderer())\n\n\n\n```\n\n\n## DC Open Data - Buildings and solar\n\nWith the help of DC Open Data’s frequently updated and granular urban data on buildings, it is straightforward to combine these into the largest single-city datasets for almost all of DC’s 110,000 residential buildings. \n- CAMA\n\n- DC Solar monthly\n\n- **Note**:\nLinking these two datasets is more complex than a single merge. The common thing is address, but CAMA doesn't have address directly. It has the Square Suffix Lot (SSL) number, which identifies the plot of land on which a building sits. Some lots have multiple buildings, and some buildings/complexes span multiple lots.\n\nWe then have a dataset with the below outline\n\n```{r, echo=FALSE}\n\n\n## AUTHENTICATE Google DRIVE account\n# drive_auth()\n# \n# \n# # download this to local drive\n# drive_download(as_id(\"1Ho9fKEotF9B6aG85SpvpNPXEK1sV4_78\"),\n#                path = \"output_data/residential_cross_sec.parquet\", overwrite = TRUE)\n\ndf <- read_parquet('data/cross_sec_api_12k.parquet')\ndf$cap_kw <- df$`Capacity (MW)`*1000\n\ndf$lat <- df$LATITUDE\ndf$lon <- df$LONGITUDE\ndf <- df %>%\n  filter(!is.na(lat) & !is.na(lon) \n         & lat != \"NA\" & lon != \"NA\") %>%\n  st_as_sf(coords = c(\"lon\", \"lat\"), crs = 4326) %>%\n   mutate(cap_kw = replace_na(cap_kw, 0))\n\n\n# add census block group data\n###############\n\nquantile_99 <- quantile(df$cap_kw, 0.99, na.rm = TRUE)\n\n\n# Preparing subsets\ndf_with_0 <- df %>% \n  filter(cap_kw == 0) %>%\n  select(SSL, STYLE_D, ROOF_D, NBHDNAME, cap_kw, max_sun_hours, min_dc_kwh) %>%\n  sample_n(2)\n\ndf_without_0 <- df %>%\n  filter(`Capacity (MW)` > 0 & `Capacity (MW)` <= quantile_99) %>%\n  select(SSL, STYLE_D, ROOF_D, NBHDNAME, cap_kw, max_sun_hours, min_dc_kwh)%>%\n  sample_n(3)\n\n# Combining the subsets\ndf_sample <- bind_rows(df_with_0, df_without_0)\n\n# drop geom\ndf_sample <- st_set_geometry(df_sample, NULL)\n\n#save\ndf_sample <- df_sample %>% select(SSL, STYLE_D, ROOF_D, NBHDNAME, cap_kw, max_sun_hours, min_dc_kwh)\n\n# write_csv(df_sample, 'kable_tab.csv')\n# \n# # Apply cell_spec to cap_mw for dynamic coloring\ndf_sample$cap_kw <- cell_spec(df_sample$cap_kw, \"html\",\n                              color = \"white\",\n                              bold = TRUE,\n                              background = spec_color(df_sample$cap_kw, end = 0.9, option = \"A\"))\n\n# Generating the table\nknitr::kable(df_sample, \"html\", escape = FALSE) %>%\n  kable_styling(full_width = F, fixed_thead=TRUE,\n                bootstrap_options = c(\"striped\", \"hover\"))\n\n\n```\n\n\nWhy is this interesting? If you look at this CITE PAPER - ML can reduce 'SOFT COSTS'\n\n## The DC Solar Market\n\nHow much does it cost to install a solar panel on average? \nInstallation cost = $13,000\n\nIn a centrally planned economy, the DC Mayor could issue an edict, and armies of government workers would install a solar panel on each roof, and the goal would be met within a week. However, that is not how a free-market democracy works, and we would \n\nA household in DC can factor in four types of incentives available for a solar installation :\n\n-\t**Federal rebate**\n-\t**SREC**\n\n::: {.callout-tip}\n## Tip with Title\nThis is an example of a callout with a title.\n:::\n\n-\t**Net metering**\n\nThere is another type of indirect incentive, which might function as a 'stick' to the above 'carrots'. This is the **Building Energy Benchmarking Policy (BEPS)**, which aims to identify and impose financial penalties on large buildings (>10,000 sq feet) with greater than average energy consumption\n\nTwo studies have been conducted on the state of solar adoption in Washington DC, by Synapse Energy Economics in 2019 and 2022.\n\nThe second study lays out the factors which hinder higher adoption in DC.\n\n- Renters (less than 30% single-family owner-occupied housing) \n- Rising ACPs - People will anticipate higher compensation in future, and may delay purchases.\n- Electricity prices: Higher electricity and enery prices, or basically that increases energy expenditure will lead people to \n\nThe shortfall between SREC supply and RPS requirement gives the revenues to DC DOEE\n\nCITE PAPER - SREC protectionism did increase adoption\n\n## Get census data using `tidyCensus`\n\n```{r, echo=TRUE, eval=FALSE}\n#| code-fold: true\n#| code-summary: \"Show the code\"\n\nst_acs <- get_acs(variables = c(total_pop = \"B02001_001E\", \n                                  owner_occupied = \"B25003_002E\",\n                                  total_occupied = \"B25003_001E\"),\n                    geography = \"block group\",\n                    geometry = TRUE,\n                    state = \"DC\", \n                    year = 2019) \n```\n\n### Aggregate solar data to the block group level\n\nWhat does data from the American Community Survey tell us, about what these \n\n```{r, echo=FALSE, message=FALSE, warning=FALSE, results=FALSE}\n\nbg_df <- st_read(\"data/solar_acs2019_bg.geojson\")\n\n# Perform a spatial join: add data from bg_df to df_sample based on their spatial relationship\n# zip_data <- zip_data %>%  st_make_valid()\n# joined_sf <- st_join(zip_data, bg_df, join = st_contains)\n\n# Improved plot for polygon sf object\n# basic_plot <- ggplot(data = bg_df) +\n#   geom_sf(aes(fill = total_capacity), color = \"black\", size = 0.2) +  # Fill polygons and add borders\n#   scale_fill_viridis(option = \"C\", direction = -1) +  # Viridis color scale\n#   labs(\n#     title = \"Per Capita Solar Capacity\",\n#     fill = \"Per Capita kW\",\n#     caption = \"Data Source: ACS 2019, DCPSC 2023\"\n#   ) +\n#   theme_minimal() +\n#   theme(\n#     legend.position = \"right\",\n#     plot.title = element_text(hjust = 0.5),  # Center the plot title\n#     plot.caption = element_text(hjust = 0, size = 8)  # Align caption\n#   )\n# \n# basic_plot\n# \n# model_1 <- lm(pc_capkw ~ own_rate, data = bg_df)\n# # Calculate robust standard errors\n# # robust_se1 <- vcovHC(model_1, type = \"HC1\")\n# # robust_se1 <- as.vector(coeftest(model_1, vcovHC(model_1, type = \"HC1\"))[, \"Std. Error\"])\n# -\n# Assuming 'joined_sf' is your dataframe with 'own_rate' and 'tot_capkw' variables.\n\n# Create 10 quantiles of ownership rate\nbg_df <- bg_df %>%\n  mutate(quantile = ntile(own_rate, 20))\n\n# Compute the mean of 'tot_capkw' within each quantile\nquantile_avgs <- bg_df %>%\n  group_by(quantile) %>%\n  summarise(tot_cap = sum(total_capacity),\n            tot_pop = sum(total_pop)) %>%\n  mutate(cap_kw_pc = tot_cap/tot_pop)\n\n###########################################################\n# Plot the averages as points\nggplot(quantile_avgs, aes(x = as.factor(quantile), y = cap_kw_pc)) +\n  geom_point(aes(color = as.factor(quantile)), size = 3) +\n  geom_smooth(aes(x = as.numeric(as.factor(quantile))), method = \"lm\", formula = y ~ x, se = TRUE, color = \"blue\") +\n  labs(x = \"Ownership Rate Quantile\", y = \"Average Total Capacity (KW)\", title = \"Average Total Capacity by Ownership Rate Quantiles\") +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 90, \n                                   vjust = 0.5, \n                                   hjust=1),\n        legend.position = \"none\")\n\n# Note: Replace 'joined_sf' with your actual dataframe name.\n###########################################################\n\n```\n\n\n## Ownership correlates with solar adoption.\n\n## TODO map layer different\n\n# Building level maps\n\nThe following shows a simple\n\n```{r, echo=FALSE}\nlibrary(leaflet)\nlibrary(RColorBrewer)\n\nward_data <- readRDS(\"data/ward_solar.rds\")\nzip_data <- readRDS(\"data/zipcode_solar.rds\")\nsolar_build <- readRDS(\"data/solar_build.rds\")\n\ndata <- zip_data\n# Replace \"ward\" with \"zipcode\" as needed\nspatialLevel <- \"ward\" # or \"zipcode\"\n\n# Check the spatial level and generate the map accordingly\npal <- colorNumeric(palette = \"YlOrRd\", domain = data$total_capacity_mw)\n  \n# map <- leaflet(zip_data) %>%\n#     addProviderTiles(providers$CartoDB.Positron) %>%\n#     addPolygons(\n#       layerId = ~NAME,\n#       fillColor = ~pal(total_capacity_mw),\n#       color = \"#444444\",\n#       weight = 1,\n#       smoothFactor = 0.5,\n#       popup = ~paste(\"Zip/Ward:\", NAME,\n#                      \"<br>Total Capacity MW:\", total_capacity_mw,\n#                      \"<br>Percentage Solar:\", perc_solar),\n#       highlightOptions = highlightOptions(weight = 2, \n#                                           color = \"white\",\n#                                           bringToFront = TRUE))\n\n# print(map)\n\n########################################################3\n## building\n\nspatialLevel <- \"build\" # or \"zipcode\"\n\n# Check the spatial level and generate the map accordingly\npal <- colorNumeric(palette = \"YlOrRd\", domain = solar_build$`Capacity (MW)`)\n  \nmap <- leaflet(solar_build) %>%\n    addProviderTiles(providers$CartoDB.Positron) %>%\n    addPolygons(\n      layerId = ~Number,\n      fillColor = ~pal(`Capacity (MW)`),\n      color = \"#444444\",\n      weight = 1,\n      smoothFactor = 0.5,\n      popup = ~paste(\"Address\", `Facility Address`,\n                     \"<br>Total Capacity MW:\", `Capacity (MW)`\n                     # \"<br>Percentage Solar:\",\n                     ),\n      highlightOptions = highlightOptions(weight = 2, color = \"white\", bringToFront = TRUE)) %>%\n    setView(lng = -77.0164, lat = 38.9047, zoom = 12)  # Set initial view; adjust coordinates and zoom as needed\n\n# Add a mini-map\nmap %>% addMiniMap(tiles = providers$CartoDB.Positron,\n                   toggleDisplay = TRUE,\n                   position = \"bottomright\")\n\nprint(map)\n\n\n```\n\n\n\n\n## Check out this in-progress dashboard here!\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":{"html_document":{"code-fold":true}},"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"output-file":"dc_solar_web.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.433","theme":"cosmo","title":"cross_section_models","author":"hk939","date":"2024-02-26"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}